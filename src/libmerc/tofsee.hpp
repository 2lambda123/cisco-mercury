// tofsee.hpp
//
// initial message de-obfuscation and parsing

#ifndef TOFSEE_HPP
#define TOFSEE_HPP

#include "datum.h"
#include "json_object.h"
#include "utils.h"

class tofsee_initial_message {
    static constexpr uint8_t permutation[256] = {
        0x00,0x20,0x40,0x60,0x80,0xa0,0xc0,0xe0,
        0x01,0x21,0x41,0x61,0x81,0xa1,0xc1,0xe1,
        0x02,0x22,0x42,0x62,0x82,0xa2,0xc2,0xe2,
        0x03,0x23,0x43,0x63,0x83,0xa3,0xc3,0xe3,
        0x04,0x24,0x44,0x64,0x84,0xa4,0xc4,0xe4,
        0x05,0x25,0x45,0x65,0x85,0xa5,0xc5,0xe5,
        0x06,0x26,0x46,0x66,0x86,0xa6,0xc6,0xe6,
        0x07,0x27,0x47,0x67,0x87,0xa7,0xc7,0xe7,
        0x08,0x28,0x48,0x68,0x88,0xa8,0xc8,0xe8,
        0x09,0x29,0x49,0x69,0x89,0xa9,0xc9,0xe9,
        0x0a,0x2a,0x4a,0x6a,0x8a,0xaa,0xca,0xea,
        0x0b,0x2b,0x4b,0x6b,0x8b,0xab,0xcb,0xeb,
        0x0c,0x2c,0x4c,0x6c,0x8c,0xac,0xcc,0xec,
        0x0d,0x2d,0x4d,0x6d,0x8d,0xad,0xcd,0xed,
        0x0e,0x2e,0x4e,0x6e,0x8e,0xae,0xce,0xee,
        0x0f,0x2f,0x4f,0x6f,0x8f,0xaf,0xcf,0xef,
        0x10,0x30,0x50,0x70,0x90,0xb0,0xd0,0xf0,
        0x11,0x31,0x51,0x71,0x91,0xb1,0xd1,0xf1,
        0x12,0x32,0x52,0x72,0x92,0xb2,0xd2,0xf2,
        0x13,0x33,0x53,0x73,0x93,0xb3,0xd3,0xf3,
        0x14,0x34,0x54,0x74,0x94,0xb4,0xd4,0xf4,
        0x15,0x35,0x55,0x75,0x95,0xb5,0xd5,0xf5,
        0x16,0x36,0x56,0x76,0x96,0xb6,0xd6,0xf6,
        0x17,0x37,0x57,0x77,0x97,0xb7,0xd7,0xf7,
        0x18,0x38,0x58,0x78,0x98,0xb8,0xd8,0xf8,
        0x19,0x39,0x59,0x79,0x99,0xb9,0xd9,0xf9,
        0x1a,0x3a,0x5a,0x7a,0x9a,0xba,0xda,0xfa,
        0x1b,0x3b,0x5b,0x7b,0x9b,0xbb,0xdb,0xfb,
        0x1c,0x3c,0x5c,0x7c,0x9c,0xbc,0xdc,0xfc,
        0x1d,0x3d,0x5d,0x7d,0x9d,0xbd,0xdd,0xfd,
        0x1e,0x3e,0x5e,0x7e,0x9e,0xbe,0xde,0xfe,
        0x1f,0x3f,0x5f,0x7f,0x9f,0xbf,0xdf,0xff
    };

    static void decrypt(const uint8_t *ciphertext, uint8_t *plaintext, size_t data_len) {
        uint8_t res = 198;
        for (size_t i=0; i<data_len; i++) {
            uint8_t c = *ciphertext++;
            *plaintext++ = res ^ permutation[c];
            res = c ^ 0xc6;
        }
    }

    class plaintext : public datum {
        uint8_t buffer[200];
    public:
        plaintext(datum &d) {
            if (d.length() != sizeof(buffer)) {
                d.set_null(); // error: ciphertext has wrong length
            }
            decrypt(d.data, buffer, sizeof(buffer));
            data = buffer;
            data_end = buffer + sizeof(buffer);
        }
    };

    plaintext pt;
    datum key;
    datum unknown_1;
    datum ipv4;
    datum srv_time;
    datum unknown_2;

public:

    tofsee_initial_message(datum &ct) :
        pt{ct},
        key{pt, 128},
        unknown_1{pt, 16},
        ipv4{pt, 4},
        srv_time{pt, 4},
        unknown_2{pt, 48} { }

    void write_json(json_object &o, bool=true) const {
        if (!is_not_empty()) {
            return;
        }
        o.print_key_hex("key", key.data, key.length());
        o.print_key_hex("unknown_1", unknown_1.data, unknown_1.length());
        o.print_key_ipv4_addr("ipv4_addr", ipv4.data);
        o.print_key_hex("srv_time", srv_time.data, srv_time.length());
        o.print_key_hex("unknown_2", unknown_2.data, unknown_2.length());
    }

    bool is_not_empty() const {
        return unknown_2.is_not_null();
    }
};

#endif // TOFSEE_HPP
