// csv.cc
//
// Comma-Separated Value (CSV) format processing for IANA (and
// similar) files

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <regex>
#include <fstream>
#include "unistd.h"

#include "csv.h"

void write_preamble(const std::string &filename,
                    const std::string &preprocname,
                    std::vector<std::pair<std::string, std::string>> file_and_class,
                    FILE *f=stdout) {

    std::time_t timenow = time(NULL);
    static char timestamp[128] = { '\0' };
    strftime(timestamp, sizeof(timestamp) - 1, "%Y-%m-%dT%H:%M:%SZ", gmtime(&timenow));
    fprintf(f,
            "// %s\n"
            "//\n"
            "// this file was autogenerated at %s\n"
            "// you should edit the source file(s) instead of this one\n"
            "//\n"
            "// source files:\n",
            filename.c_str(),
            timestamp);
    for (const auto &fc : file_and_class) {
        fprintf(f, "//     %s\n", fc.first.c_str());
    }
    fprintf(f,
            "//\n\n"
            "#ifndef %s\n"
            "#define %s\n\n"
            "static const char UNKNOWN[] = \"UNKNOWN\";\n\n",
            preprocname.c_str(),
            preprocname.c_str());
}

void write_postamble(const char *filename, FILE *f=stdout) {
    fprintf(f, "\n#endif // %s\n\n", filename);
}

void write_class(const std::vector<std::pair<std::string, std::string>> &params,
                 const char *name,
                 FILE *f=stdout) {

    // prepare padding for alignment
    //
    const char padding[] = "                                                           ";
    size_t max = 0;
    //    size_t min = std::numeric_limits<size_t>::max();
    for (const auto &p : params) {
        if (p.first.length() > max) { max = p.first.length(); }
        // if (p.first.length() < min) { min = p.first.length(); }
    }

    fprintf(f,
            "template <typename T>\n"
            "class %s : public encoded<T> {\n"
            "    static_assert(std::is_unsigned_v<T>, \"T must be an unsigned integer\");\n"
            "public:\n"
            "    void write_json(json_object &o) const {\n"
            "        const char *name = get_name();\n"
            "        o.print_key_string(\"%s\", name);\n"
            "        if (name == UNKNOWN) {\n"
            "            o.print_key_uint(\"%s_type_code\", encoded<T>::value());\n"
            "        }\n"
            "    }\n"
            "    enum code {\n",
            name,
            name,
            name);

    for (const auto &p : params) {
        int padlen = max - p.first.length();
        fprintf(f, "        %s%.*s = %s,\n", p.first.c_str(), padlen, padding, p.second.c_str());
    }

    fprintf(f,
            "    };\n"
            "    const char *get_name() const {\n"
            "        switch(encoded<T>::value()) {\n"
            );

    for (const auto &p : params) {
        int padlen = max - p.first.length();

        // remove leading underscore, if any, from printed string
        //
        std::string tmp{p.first};
        if (tmp[0] == '_') {
            tmp.erase(0,1);
        }
        fprintf(f, "        case %s:%.*s return \"%s\";\n", p.first.c_str(), padlen, padding, tmp.c_str());
    }

    fprintf(f,
            "        default:\n"
            "            ;\n"
            "        }\n"
            "        return UNKNOWN;\n"
            "    }\n"
            "};\n\n");
}

void process_iana_csv_file(const std::string &filename,
                           const std::string &classname,
                           FILE *outfile,
                           bool verbose=false) {

    bool remove_paren_exprs = true;

    std::ifstream f(filename);

    std::vector<std::pair<std::string, std::string>> params;
    csv::get_next_line(f);  // ignore first line
    while(f) {

        std::vector<std::string> csv_line = csv::get_next_line(f);
        if (csv_line.size() > 2) {

            std::string value{csv_line[0]};
            std::string keyword{csv_line[1]};

            // transform keyword into an acceptable C++ identifier
            //
            std::replace(keyword.begin(), keyword.end(), '.', '_');
            std::replace(keyword.begin(), keyword.end(), '-', '_');
            std::replace(keyword.begin(), keyword.end(), ' ', '_');
            std::replace(keyword.begin(), keyword.end(), '#', '_');
            if (remove_paren_exprs) {
                size_t lparen = keyword.find('(');
                if (lparen != std::string::npos) {
                    size_t rparen = keyword.find(')', lparen);
                    if (rparen != std::string::npos) {
                        keyword.erase(lparen, rparen);
                    }
                }
                lparen = keyword.find('[');
                if (lparen != std::string::npos) {
                    size_t rparen = keyword.find(']', lparen);
                    if (rparen != std::string::npos) {
                        keyword.erase(lparen, rparen);
                    }
                }
            } else {
                std::replace(keyword.begin(), keyword.end(), '(', '_');
                std::replace(keyword.begin(), keyword.end(), ')', '_');
                std::replace(keyword.begin(), keyword.end(), ']', '_');
                std::replace(keyword.begin(), keyword.end(), '[', '_');
            }
            if (isdigit(keyword[0])) {
                keyword.insert(0, "_");
            }

            // remove duplicate and final underscores
            std::string tmp;
            char last = '\0';
            for (const auto &k : keyword) {
                if (k != '_' or last != '_') {
                    tmp += k;
                }
                last = k;
            }
            if (tmp.back() == '_') {
                tmp.pop_back();
            }

            // add (keyword, value) to vector
            //
            params.emplace_back(tmp, value);
        }
    };

    // remove Reserved, Unassigned, and Private elements
    //
    const auto & predicate = [verbose](const std::pair<std::string, std::string> p){

        bool remove = std::regex_search(p.first, std::regex("Reserved.*"))
            or std::regex_search(p.first, std::regex("RESERVED"))
            or std::regex_search(p.first, std::regex("Unassigned.*"))
            or std::regex_search(p.first, std::regex("Private"))
            or not std::regex_search(p.second, std::regex("[0-9]*"));

        if (verbose and remove) {
            fprintf(stderr, "note: removing (%s, %s)\n", p.first.c_str(), p.second.c_str());
        }
        return remove;
    };
    params.erase(std::remove_if(params.begin(), params.end(), predicate), params.end());

    write_class(params, classname.c_str(), outfile);

}

void usage(const char *progname) {
    fprintf(stderr, "usage: %s outfile=<of> <infile.csv>:<classname> [ <infile.csv>:<classname> ... ]\n", progname);
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[]) {

    // process command line arguments
    //
    bool verbose = false;
    std::string outfilename;
    std::string dirname;
    std::vector<std::pair<std::string, std::string>> file_and_class;
    for (int i=1; i<argc; i++) {
        std::string s(argv[i]);
        size_t colon = s.find(":");
        if (colon != std::string::npos) {
            std::string prefix{s.substr(0, colon)};
            std::string suffix{s.substr(colon+1)};
            file_and_class.emplace_back(prefix, suffix);
        } else {
            if (std::regex_search(s, std::regex{"outfile=.*"})) {
                outfilename = s.substr(8);
            }
            if (std::regex_search(s, std::regex{"verbose=true"})) {
                verbose = true;
            }
            if (std::regex_search(s, std::regex{"dir=.*"})) {
                dirname = s.substr(4);
            }
        }
    }

    if (outfilename == "") {
        fprintf(stderr, "error: no output file specified on command line\n");
        usage(argv[0]);
    }
    FILE *outfile = fopen(outfilename.c_str(), "w");

    if (dirname != "") {
        if (chdir(dirname.c_str()) != 0) {
            fprintf(stderr, "error: could not change working directory to %s\n", dirname.c_str());
            usage(argv[0]);
        }
    }

    // create preprocessor names for #defines
    //
    std::string preproc{outfilename};
    std::replace(preproc.begin(), preproc.end(), '.', '_');
    std::transform(preproc.begin(), preproc.end(), preproc.begin(), ::toupper);

    // write out preambles, tables, and postamble
    //
    write_preamble(outfilename, preproc, file_and_class, outfile);
    for (const auto &fc : file_and_class) {
        process_iana_csv_file(fc.first, fc.second, outfile, verbose);
    }
    write_postamble(preproc.c_str(), outfile);

    return 0;
}
